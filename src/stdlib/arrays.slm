inc stdlib.slm
inc mem.slm

class arr
  prop Size int.SIZE
  prop Elem int.SIZE
  prop pData int.SIZE

end

class seq
  prop Size int.SIZE
  prop Max  int.SIZE
  prop Elem int.SIZE
  prop Data 0

  var curtemp int.SIZE
  var elemtemp 32
  
  {
  args: int[maxSize] int[elemSize] ptr[seqay]
  returns: ptr[seqay]

  Creates an seqay
  }
  proc new 2 1
    copy (heap.zalloc) seq.curtemp swap put disc
    seq.elemtemp swap put disc

    seq.curtemp read
    seq.Elem .
    swap put disc
    
    seq.curtemp read
    seq.Max .

    seq.elemtemp read
    seq.Data -

    put disc
    
    seq.curtemp read
    seq.Size .
    0
    put disc
  
    seq.curtemp read
    ret
  end
  
  {
  args: int[size] ptr[seqay]
  returns: ptr[seqay]
  }
  proc setlen 2 1
    swap seq.curtemp swap put disc

    seq.curtemp read
    seq.Size .

    swap put disc
    
    seq.curtemp read
    ret
  end
  
  {
  args: ptr[seqay]
  returns: int[size] ptr[seqay]
  }
  proc len 1 2
    copy
    seq.Size . read
  
    ret
  end
  
  {
  args: ptr[data] ptr[seqay]
  returs: ptr[seqay]
  }
  proc pushint 2 1
    seq.elemtemp swap put disc
    seq.curtemp swap put disc
    
    seq.curtemp read
    seq.Elem . read
    
    seq.curtemp read
    seq.Size . read
  
    1 + *
    
    seq.curtemp read
    seq.Max . read
    > if ["ARRAY OVERFLOW" (cstr.println) -1 quit]
    
    seq.curtemp read
    seq.Elem . read
    
    seq.curtemp read
    seq.Size . read
    *
    
    seq.curtemp read
    seq.Data .
    +
    
    seq.elemtemp read
    put disc
    
    seq.curtemp read
    seq.Size .

    copy read
    1 +
    put
  
    ret
  end
  
  {
  args: ptr[data] ptr[seqay]
  returs: ptr[seqay]
  }
  proc push 2 1
    seq.elemtemp swap put disc
    seq.curtemp swap put disc
    
    seq.curtemp read
    seq.Elem . read
    
    seq.curtemp read
    seq.Size . read
  
    1 + *
    
    seq.curtemp read
    seq.Max . read
    > if ["ARRAY OVERFLOW" (cstr.println) -1 quit]
    
    seq.curtemp read
    seq.Elem . read
    
    seq.curtemp read
    seq.Size . read
    *
    
    seq.curtemp read
    seq.Data .
    +
    
    seq.elemtemp read
    
    seq.curtemp read
    seq.Elem . read
    (mem.copy)
    
    seq.curtemp read
    seq.Size .

    copy read
    1 +
    put
  
    ret
  end

  proc extend 2 1
    swap seq.curtemp swap put disc

    seq.curtemp read
    seq.Size . read +
    
    seq.curtemp read
    seq.Size . swap

    put disc
  
    seq.curtemp read

    ret
  end
  
  proc getaddr 2 2 
    swap seq.curtemp swap put disc
  
    copy
    seq.curtemp read
    seq.Size . read
    > if [ "INDEX ERROR" (cstr.println) disc -1 quit ]
    
    seq.curtemp read
    seq.Elem . read
    *

    seq.curtemp read
    seq.Data .
    +

    seq.curtemp read
    swap

    ret
  end
  
  proc print 1 0
    seq.curtemp swap put disc
    "[" (cstr.print)
    seq.curtemp read
    seq.Data . (cstr.print)
    
    seq.curtemp read
    seq.Size . read

    1 == if [
      "]" (cstr.println)
      ret
    ]

    0
    do
      ", " (cstr.print)

      1 +
      copy
      seq.curtemp read
      seq.Elem . read
      *
    
      seq.curtemp read
      seq.Data .
      + (cstr.print)
 
      copy
      seq.curtemp read
      seq.Size . read
      1 - <
    end
    disc

    "]" (cstr.println)
    
    ret
  end

  proc popaddr 1 2
    seq.curtemp swap put disc
    
    seq.curtemp read
    seq.Size . read

    1 -

    seq.curtemp read
    seq.Elem . read
    *
    
    seq.curtemp read
    seq.Data . +

    seq.elemtemp
    
    swap put disc

    seq.curtemp read
    seq.Size .

    copy read
    1 -
    put disc

    seq.curtemp read
    seq.elemtemp read
    ret
  end

  proc pop 1 2
    seq.curtemp swap put disc
    
    seq.curtemp read
    seq.Size . read

    1 -

    seq.curtemp read
    seq.Elem . read
    *
    
    seq.curtemp read
    seq.Data . + copy

    seq.elemtemp

    swap

    seq.curtemp read
    seq.Elem . read
    (mem.copy) 

    
    seq.curtemp read
    seq.Elem . read
    (mem.zero)

    seq.curtemp read
    seq.Size .

    copy read
    1 -
    put disc

    seq.curtemp read
    seq.elemtemp
    ret
  end

  proc free 1 0
    (heap.free)
  
    ret
  end

  {TODO: proc in 2 2}
end

class llentry
  {TODO: Not recursive}

  prop next int.SIZE
  prop data 0
 
  proc new 1 1
    8 +
    (heap.zalloc)

    ret
  end

  proc free 1 0
    copy llentry.next . read
    copy NULL != if [
      copy (llentry.free)
    ]
    disc

    (heap.free)
    
    ret
  end

  proc last 1 1
    copy llentry.next . read
    NULL == if [
      ret
    ]
    
    llentry.next . read
    (llentry.last)

    ret
  end

  proc append 2 1
    covr llentry.next . swap put disc
      
    ret
  end
  
  proc print 2 1
    covr llentry.data .
    covr () disc
    
    covr llentry.next . read
    covr

    covr NULL != if [
      ", " (cstr.print)
      (llentry.print) 0
    ]
    disc
    disc
    disc

    ret
  end
end

class llist
  prop entry int.SIZE
  prop root int.SIZE

  var curtemp int.SIZE

  proc new 1 1
    16 (heap.zalloc)

    covr
    covr llist.entry . swap put disc
    swap disc

    ret
  end

  proc free 1 0
    copy llist.root . read
    copy NULL != if [
      copy (llentry.free)
    ]
    disc

    (heap.free)

    ret
  end

  proc last 1 2
    copy llist.root . read NULL == if [NULL ret]
    copy llist.root . read (llentry.last)
    
    ret
  end

  proc len 1 1
    {TODO: Implement}
    copy llist.root . read NULL == if [disc 0 ret]
    llist.root . read
    NULL swap
    do
      swap 1 +
      swap

      llentry.next . read
      copy NULL !=
    end
    disc

    ret
  end

  proc append 2 1
    swap llist.curtemp swap put disc

    llist.curtemp read
    (llist.last) swap disc

    NULL == if [
      llist.curtemp read
      llist.entry . read
      (llentry.new)

      llist.curtemp read
      llist.root . swap put read
      llentry.data .
      swap
      
      llist.curtemp read
      llist.entry . read
      (mem.copy)

      llist.curtemp read
      ret
    ]
    
    llist.curtemp read
    llist.entry . read
    (llentry.new)
    
    llist.curtemp read
    (llist.last) swap disc
    swap (llentry.append)
    disc
     
    llist.curtemp read
    (llist.last) swap disc
    llentry.data .
    swap

    llist.curtemp read
    llist.entry . read
    (mem.copy)
    
    llist.curtemp read

    ret
  end

  proc print 2 1
    covr llist.root . read
    covr

    covr NULL != if [
      (llentry.print) 0
    ]
    disc
    disc
    disc

    ret
  end
end
